"""
Safe Code Execution Module
安全代碼執行模組

This module provides a secure way to execute pandas/plotly code
generated by LLM, using AST validation and sandboxing.
"""

import ast
import pandas as pd
import plotly.express as px
import signal
import sys

# resource module only available on Unix systems
if sys.platform != 'win32':
    import resource
else:
    resource = None  # type: ignore
    
from typing import Any, Dict, Set, Optional
from functools import wraps
import logging

logger = logging.getLogger('analyst.safe_exec')

# Allowed pandas DataFrame methods
ALLOWED_DATAFRAME_METHODS: Set[str] = {
    # Selection
    'head', 'tail', 'sample', 'iloc', 'loc', 'at', 'iat',
    # Aggregation
    'groupby', 'sum', 'mean', 'count', 'min', 'max', 'std', 'var',
    'median', 'mode', 'agg', 'aggregate', 'nunique', 'value_counts',
    # Sorting
    'sort_values', 'sort_index', 'nlargest', 'nsmallest',
    # Filtering
    'query', 'filter', 'where', 'mask', 'dropna', 'fillna',
    'drop_duplicates', 'unique',
    # Transformation
    'apply', 'map', 'replace', 'rename', 'reset_index', 'set_index',
    'pivot', 'pivot_table', 'melt', 'stack', 'unstack',
    # Merging
    'merge', 'join', 'concat',
    # DateTime
    'dt', 'resample',
    # String operations
    'str',
    # Type conversion
    'astype', 'to_datetime', 'to_numeric',
    # Info
    'columns', 'dtypes', 'shape', 'size', 'empty',
    # Output
    'to_dict', 'to_json', 'to_string',
}

# Allowed plotly express functions
ALLOWED_PLOTLY_FUNCTIONS: Set[str] = {
    'bar', 'line', 'scatter', 'pie', 'histogram', 'box',
    'violin', 'area', 'funnel', 'treemap', 'sunburst',
    'scatter_matrix', 'parallel_coordinates', 'choropleth',
}

# Forbidden names that should never be accessed
FORBIDDEN_NAMES: Set[str] = {
    '__import__', 'import', 'exec', 'eval', 'compile',
    'open', 'file', 'input', 'raw_input',
    'globals', 'locals', 'vars', 'dir',
    'getattr', 'setattr', 'delattr', 'hasattr',
    '__builtins__', '__class__', '__bases__', '__subclasses__',
    'os', 'sys', 'subprocess', 'shutil', 'pathlib',
    'socket', 'requests', 'urllib', 'http',
    '__code__', '__globals__', '__dict__',
}

# Maximum execution time (seconds)
MAX_EXECUTION_TIME = 10

# Maximum memory (bytes) - 256MB
MAX_MEMORY = 256 * 1024 * 1024


class UnsafeCodeError(Exception):
    """Raised when code contains unsafe operations"""
    pass


class ExecutionTimeoutError(Exception):
    """Raised when code execution times out"""
    pass


class SafeCodeValidator(ast.NodeVisitor):
    """
    AST visitor that validates code safety.
    Ensures only allowed operations are used.
    """
    
    def __init__(self):
        self.errors: list = []
        self.allowed_names = {'df', 'pd', 'px', 'fig', 'result', 'True', 'False', 'None'}
    
    def visit_Import(self, node: ast.Import) -> None:
        """Block all imports"""
        self.errors.append(f"Import statements are not allowed: {ast.dump(node)}")
        self.generic_visit(node)
    
    def visit_ImportFrom(self, node: ast.ImportFrom) -> None:
        """Block all from imports"""
        self.errors.append(f"Import statements are not allowed: {ast.dump(node)}")
        self.generic_visit(node)
    
    def visit_Call(self, node: ast.Call) -> None:
        """Validate function calls"""
        # Check for forbidden function names
        if isinstance(node.func, ast.Name):
            if node.func.id in FORBIDDEN_NAMES:
                self.errors.append(f"Forbidden function: {node.func.id}")
        
        # Check for dangerous attribute access
        elif isinstance(node.func, ast.Attribute):
            attr_name = node.func.attr
            if attr_name in FORBIDDEN_NAMES:
                self.errors.append(f"Forbidden attribute: {attr_name}")
            
            # Validate plotly express calls
            if isinstance(node.func.value, ast.Name) and node.func.value.id == 'px':
                if attr_name not in ALLOWED_PLOTLY_FUNCTIONS:
                    self.errors.append(f"Plotly function not allowed: {attr_name}")
        
        self.generic_visit(node)
    
    def visit_Attribute(self, node: ast.Attribute) -> None:
        """Check for dangerous attribute access"""
        if node.attr in FORBIDDEN_NAMES:
            self.errors.append(f"Forbidden attribute access: {node.attr}")
        
        # Check for dunder attributes
        if node.attr.startswith('__') and node.attr.endswith('__'):
            if node.attr not in {'__len__', '__iter__', '__getitem__'}:
                self.errors.append(f"Dunder attribute not allowed: {node.attr}")
        
        self.generic_visit(node)
    
    def visit_Name(self, node: ast.Name) -> None:
        """Check for forbidden names"""
        if node.id in FORBIDDEN_NAMES:
            self.errors.append(f"Forbidden name: {node.id}")
        self.generic_visit(node)
    
    def validate(self, code: str) -> bool:
        """
        Validate code safety.
        Returns True if safe, raises UnsafeCodeError if not.
        """
        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            raise UnsafeCodeError(f"Syntax error in code: {e}")
        
        self.errors = []
        self.visit(tree)
        
        if self.errors:
            raise UnsafeCodeError(f"Unsafe code detected: {'; '.join(self.errors)}")
        
        return True


def timeout_handler(signum, frame):
    """Signal handler for execution timeout"""
    raise ExecutionTimeoutError("Code execution timed out")


def safe_eval(code: str, df: pd.DataFrame, timeout: int = MAX_EXECUTION_TIME) -> Any:
    """
    Safely evaluate pandas expression.
    
    Args:
        code: The pandas code to evaluate
        df: The DataFrame to operate on
        timeout: Maximum execution time in seconds
    
    Returns:
        The result of the evaluation
    
    Raises:
        UnsafeCodeError: If code contains unsafe operations
        ExecutionTimeoutError: If execution times out
    """
    # Validate code safety
    validator = SafeCodeValidator()
    validator.validate(code)
    
    # Create restricted namespace
    namespace = {
        'df': df.copy(),  # Work on a copy
        'pd': pd,
        '__builtins__': {
            'True': True,
            'False': False,
            'None': None,
            'len': len,
            'str': str,
            'int': int,
            'float': float,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'range': range,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'sum': sum,
            'min': min,
            'max': max,
            'abs': abs,
            'round': round,
        }
    }
    
    logger.info(f"Executing safe eval: {code[:100]}...")
    
    try:
        # Note: signal.alarm doesn't work on Windows
        # For production, consider using multiprocessing with timeout
        result = eval(code, namespace)
        return result
    except Exception as e:
        logger.error(f"Safe eval failed: {e}")
        raise


def safe_exec(code: str, df: pd.DataFrame, timeout: int = MAX_EXECUTION_TIME) -> Dict[str, Any]:
    """
    Safely execute pandas/plotly code.
    
    Args:
        code: The code to execute
        df: The DataFrame to operate on
        timeout: Maximum execution time in seconds
    
    Returns:
        Dictionary containing namespace variables after execution
    
    Raises:
        UnsafeCodeError: If code contains unsafe operations
        ExecutionTimeoutError: If execution times out
    """
    # Validate code safety
    validator = SafeCodeValidator()
    validator.validate(code)
    
    # Create restricted namespace
    namespace = {
        'df': df.copy(),  # Work on a copy
        'pd': pd,
        'px': px,
        '__builtins__': {
            'True': True,
            'False': False,
            'None': None,
            'len': len,
            'str': str,
            'int': int,
            'float': float,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'range': range,
            'enumerate': enumerate,
            'zip': zip,
            'sorted': sorted,
            'sum': sum,
            'min': min,
            'max': max,
            'abs': abs,
            'round': round,
        }
    }
    
    logger.info(f"Executing safe exec: {code[:100]}...")
    
    try:
        exec(code, namespace)
        # Return only safe variables
        return {
            k: v for k, v in namespace.items() 
            if not k.startswith('_') and k not in {'pd', 'px'}
        }
    except Exception as e:
        logger.error(f"Safe exec failed: {e}")
        raise


def validate_code_safety(code: str) -> tuple[bool, Optional[str]]:
    """
    Check if code is safe to execute without actually executing it.
    
    Args:
        code: The code to validate
    
    Returns:
        Tuple of (is_safe, error_message)
    """
    try:
        validator = SafeCodeValidator()
        validator.validate(code)
        return True, None
    except UnsafeCodeError as e:
        return False, str(e)
    except Exception as e:
        return False, f"Validation error: {e}"
